<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Radar SDK Documentation: Python wrapper usage</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ifx_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Radar SDK Documentation
   </div>
   <div id="projectbrief">Infineon software Radar SDK for the development of applications with Infineon radar devices.</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('pg_rdk_python.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Python wrapper usage </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><hr  />
 <h1><a class="anchor" id="sct_rdk_python_quick"></a>
1    Quick start guide</h1>
<h2><a class="anchor" id="sct_rdk_python_requirements"></a>
1.1 Requirements</h2>
<p>The Radar SDK Python wrapper requires Python 3 and numpy. The wrapper has been tested with Python versions 3.7, 3.8, and 3.9. The wrapper is available on following platforms:</p><ul>
<li>Windows 10 (32bit and 64bit)</li>
<li>Linux (Ubuntu 20.04, 64bit)</li>
<li>Rasperry Pi (Raspbian Buster, 32bit)</li>
</ul>
<p>If Python is not yet installed on your computer, it is recommended to install the Anaconda distribution (available for Windows and Linux) which includes Python, numpy, scipy, and many more packages.</p>
<p>On Linux you can also use the package manager of your distribution to install the requirements. For Raspbian and Ubuntu, you need to install the packages python3 and python3-numpy:</p>
<dl class="section user"><dt>Code Listing 1.1.1</dt><dd><pre class="fragment">sudo apt update
sudo apt install python3 python3-numpy
</pre></dd></dl>
<p>To run the application examples it is further required to install scipy and matplotlib. </p><dl class="section user"><dt>Code Listing 1.1.2</dt><dd><pre class="fragment">sudo apt install python3-scipy python3-matplotlib
</pre></dd></dl>
<h2><a class="anchor" id="sct_rdk_python_running_the_example"></a>
1.2 Running the example</h2>
<p>The Python Radar SDK wrapper and an example script can be found in the directory <em> sdk/py/wrapper/ </em> of the release package.</p>
<p>Start the script example.py either in an integrated development environment like Spyder or directly by invoking Python from the command line. The example script connects to the first radar device found, sets the default configuration, and fetches 10 frames. If successful, the output should look similar as shown in Figure 1</p>
<div class="image">
<img src="img_python_fig_1_output_of_example.png" alt="" width="600px"/>
<div class="caption">
Figure 1.1 Output of example.py.</div></div>
<p> <br  />
If the script aborts with the error message "ModuleNotFoundError"</p>
<dl class="section user"><dt>Code Listing 1.2.1</dt><dd><pre class="fragment">ModuleNotFoundError: No module named 'ifxRadarSDK'
</pre></dd></dl>
<p>make sure that the module ifxRadarSDK.py is available and you are in the right directory <em>sdk/py/wrapper/</em>.</p>
<p>If you see the exception ifxRadarSDK.RadarSDKNoDeviceError </p><dl class="section user"><dt>Code Listing 1.2.2</dt><dd><pre class="fragment">ifxRadarSDK.RadarSDKNoDeviceError: no compatible radar device found (IFX_ERROR_NO_DEVICE)
</pre></dd></dl>
<p>no radar device was found. Make sure that a radar board is connected to the computer and the status LED indicates that the device is available (for RadarBaseboardMCU7: led is green flashing). You will need firmware version 2.0 or higher. On Linux make sure that you have access to the device file <em> /dev/ttyACM0 </em>, see also the section "Setup Build environment guidelines" in the documentation (<em> folder doc/ </em>).</p>
<p>The Python Radar SDK wrapper depends on the compiled radar SDK library (radar_sdk.dll on Windows, libradar_sdk.so on Linux). The wrapper first tries to find the file in the directory of the wrapper (the directory that contains ifxRadarSDK.py). If not found, the library is searched in the directory <em> lib/ARCH/ </em> where ARCH depends on the current platform and either win32_x86, win32_x64, or raspi.</p>
<p>If you copy the library (radar_sdk.dll or libradar_sdk.so) directly into the directory that contains the Python Radar SDK wrapper, make sure that the version matches. On Windows, the library must match your Python interpreter: A 32bit Python interpreter requires the 32bit library, and a 64bit Python interpreter requires the 64bit library. If the versions do not match you will see an OSError: </p><dl class="section user"><dt>Code Listing 1.2.3</dt><dd><pre class="fragment">OSError: [WinError 193] %1 is not a valid Win32 application
</pre></dd></dl>
<p><br  />
</p>
<h2><a class="anchor" id="sct_rdk_python_help_function"></a>
1.3   Help function</h2>
<p>To get further information about the functions and methods of the Radar SDK Python wrapper, you can use Python's help function to see the full documentation. Inside the Python interpreter, load the ifxRadarSDK module and call help on it:</p>
<dl class="section user"><dt>Code Listing 1.3.1</dt><dd><pre class="fragment">Python 3.8.5 (default, Jul 28 2020, 12:59:40)
[GCC 9.3.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; import ifxRadarSDK
&gt;&gt;&gt; help(ifxRadarSDK)
</pre></dd></dl>
<p>The output looks similar as depicted in Figure 1.2. Integrated development environments typically also allow to read this documentation.</p>
<div class="image">
<img src="img_python_fig_2_documentation_of_the_python.png" alt="" width="600px"/>
<div class="caption">
Figure 1.2 Documentation of the Python SDK wrapper as shown by the function help.</div></div>
<p> <br  />
 </p>
<h2><a class="anchor" id="sct_rdk_python_running_applications"></a>
1.4    Running the example applications</h2>
<p>The Python example application can be found in the folder <em> apps/py/examples/ </em>. Like for the wrapper example the application examples need the module ifxRadarSDK.py to be in the same directory. To run the examples, please copy the wrapper ifxRadarSDK.py in <em> sdk/py/wrapper/ </em> to the directory <em> apps/py/examples </em>. In addition, copy the radar SDK library (libradar_sdk.so on Linux, radar_sdk.dll on Windows) from <em> lib/ARCH/ </em> to the directory of the examples. Here, ARCH describes your current platform which is either win32_x86 for 32bit Windows, win32_x64 for 64bit Windows, raspi for Raspbian Buster, or linux_x64 for Ubuntu 20.04.</p>
<p>When starting the applications additional parameters can be passed to configure the number of frames or the frame rate. Passing -h will show the possible options for the module as shown in Figure 1.3.</p>
<div class="image">
<img src="img_python_fig_3_usage_of_static_distance_on_rasp_pi.png" alt="" width="600px"/>
<div class="caption">
Figure 1.3 Usage of static_distance.py on a Raspberry Pi.</div></div>
<p> <br  />
 Starting the script static_distance.py allows to measure distance to static targets like walls. The output should be similar to Figure 1.4</p>
<div class="image">
<img src="img_python_fig_4_output_of_running_static_distance.png" alt="" width="600px"/>
<div class="caption">
Figure 1.4 Output of running static_distance.py.</div></div>
<p> <br  />
 The doppler.py module calculates and plots the range-Doppler map. Figure 1.5 shows a range-Doppler map as outputted by the script doppler.py.</p>
<div class="image">
<img src="img_python_fig_5_range_doppler_map_ass_displayed_by_doppler.png" alt=""/>
<div class="caption">
Figure 1.5 The range-Doppler map as displayed by doppler.py.</div></div>
<p> The magnitude in dB is shown as a function of velocity and distance." width=600px <br  />
 </p><hr  />
 <h1><a class="anchor" id="sct_rdk_python_algo"></a>
2 Writing a Radar application using Python</h1>
<p>This section illustrates the usage of the SDK Python wrapper. The examples can be used as a starting point for writing custom applications. Typically, a program will import the Python wrapper, connect to the Radar sensor, set a specific Radar configuration, and then in a loop fetch data from the Radar sensor and process it.</p>
<h2><a class="anchor" id="sct_rdk_python_algo_import"></a>
2.1 Importing the Python wrapper</h2>
<p>The first step is to import the Python wrapper. Additionally, the numpy library is imported here as it is used for calculations (e.g Fast Fourier Transform, shape, pad etc.) in this example. If the files ifxRadarSDK.py, ifxError.py, and the library (radar_sdk.dll on Windows, libradar_sdk.so on Linux) are in the same directory as your Python script, the wrapper and numpy library can be imported using:</p>
<dl class="section user"><dt>Code Listing 2.1.1</dt><dd><pre class="fragment">from ifxRadarSDK import *
import numpy as np
</pre></dd></dl>
<p>If the Python wrapper is in a different location, you need to add this directory to the path:</p>
<dl class="section user"><dt>Code Listing 2.1.2</dt><dd><pre class="fragment">import sys
sys.path.append('&lt;absolute-or-relative-path-to-directory-hosting-sdk-wrapper&gt;')
from ifxRadarSDK import *
</pre></dd></dl>
<p>Once the library is imported, the version can be checked by the string returned using the get_version_full() function</p>
<dl class="section user"><dt>Code Listing 2.1.3</dt><dd><pre class="fragment">print ("Radar SDK Version: " + get_version_full())
</pre></dd></dl>
<h2><a class="anchor" id="sct_rdk_python_algo_connect"></a>
2.2 Connecting to the Radar sensor</h2>
<p>Next, a connection to a Radar sensor is established. Make sure that the Radar board is connected to your computer. To connect to the first Radar board found, you can either use</p>
<dl class="section user"><dt>Code Listing 2.2.1</dt><dd><pre class="fragment">device = Device()
</pre></dd></dl>
<p>or </p><dl class="section user"><dt>Code Listing 2.2.2</dt><dd><pre class="fragment">with Device() as device:
     #block code
     #block code
     ...
     #block code
</pre></dd></dl>
<p>The later version that uses the 'with' statement has the advantage that the connection to the Radar board is automatically closed after leaving the with block. In the code listing 2.2.1 that doesn't use the 'with' statement, you have to manually disconnect using</p>
<dl class="section user"><dt>Code Listing 2.2.3</dt><dd><pre class="fragment">del device
</pre></dd></dl>
<p>It is also possible to connect to a Radar sensor with a specific UUID:</p>
<dl class="section user"><dt>Code Listing 2.2.4</dt><dd><pre class="fragment">device = Device(uuid="01234567-89ab-cdef-0123-456789abcdef")
</pre></dd></dl>
<p>To get a list of all connected Radar sensors you can use the method </p><dl class="section user"><dt>Code Listing 2.2.5</dt><dd><pre class="fragment">Device.get_list()
</pre></dd></dl>
<p>For more details, please refer to the docstring documentation of the Python wrapper.</p>
<h2><a class="anchor" id="sct_rdk_python_algo_config"></a>
2.3 Setting a Radar configuration</h2>
<p>A particular configuration is written to the Radar sensor in the next step. The following function sets a default configuration (for the values of the default configuration please refer to the docstring documentation of the Python wrapper):</p>
<dl class="section user"><dt>Code Listing 2.3.1</dt><dd><pre class="fragment">device.set_config()
</pre></dd></dl>
<p>The configuration consists of following parameters:</p>
<a class="anchor" id="Table 2.1"></a>
<table class="doxtable">
<caption>Radar parameters</caption>
<tr>
<th><b>Parameter</b> Name </th><th><b>Description</b>   </th></tr>
<tr>
<td><b>sample_rate_Hz</b>  </td><td>ADC sampling frequency  </td></tr>
<tr>
<td><b>rx_mask</b>  </td><td>Bit-mask indicating used receive antennas  </td></tr>
<tr>
<td><b>tx_mask</b>  </td><td>Bit-mask indicating used transmit antennas  </td></tr>
<tr>
<td><b>tx_power_level</b>  </td><td>Transmit power level selectable 5 bit unsigned  </td></tr>
<tr>
<td><b>if_gain_dB</b>  </td><td>intermediate frequency gain value in dB  </td></tr>
<tr>
<td><b>lower_frequency_Hz</b>  </td><td>Chirp start frequency in Hz  </td></tr>
<tr>
<td><b>upper_frequency_Hz</b>  </td><td>Chirp end frequency in Hz  </td></tr>
<tr>
<td><b>num_samples_per_chirp</b>  </td><td>number of receive samples corresponding to 1 chirp  </td></tr>
<tr>
<td><b>num_chirps_per_frame</b>  </td><td>Number of chirps in a Radar frame  </td></tr>
<tr>
<td><b>chirp_repetition_time_s</b>  </td><td>Time between consecutive chirp (same-frame) start points in seconds  </td></tr>
<tr>
<td><b>frame_repetition_time_s</b>  </td><td>Time in seconds between consecutive frame starts  </td></tr>
<tr>
<td><b>mimo_mode</b>  </td><td><p class="starttd">multiple input multiple output configured "on/off" </p>
<p class="endtd"></p>
</td></tr>
</table>
<p>Here is an example for setting a configuration:</p>
<dl class="section user"><dt>Code Listing 2.3.2</dt><dd><pre class="fragment"># set device configuration
device.set_config(
    sample_rate_Hz = 2e6,                # ADC sample rate of 2MHz
    rx_mask = 3,                         # RX antennas 1 and 2 activated
    tx_mask = 1,                         # TX antenna 1 activated
    tx_power_level = 29,                 # TX power level of 29
    if_gain_dB = 33,                     # 33dB if gain
    lower_frequency_Hz = 60_500_000_000, # lower frequency: 60.5GHz
    upper_frequency_Hz = 62_300_000_000, # upper frequency: 62.3GHz
    num_samples_per_chirp = 64,          # 64 samples per chirp
    num_chirps_per_frame = 64,           # 64 chirps per frame
    chirp_repetition_time_s = 5e-4,      # Chirp repetition time (or pulse repetition time) of 500us
    frame_repetition_time_s = 0.25,      # Frame repetition time of 0.25s (frame rate of 4Hz)
    mimo_mode = "off")                   # MIMO disabled
</pre></dd></dl>
<p>If not all parameters are set, then the default values are used. As the default values might change over time, it is recommended to always set all configuration values explicitly.</p>
<h2><a class="anchor" id="sct_rdk_python_algo_data"></a>
2.4 Fetching Radar data</h2>
<p>Once the device configuration is set, a frame instance needs to be created. This frame will hold the data received from the radar device. The frame instance is created using the following code.</p>
<dl class="section user"><dt>Code Listing 2.4.1</dt><dd><pre class="fragment">frame = device.create_frame_from_device_handle()
</pre></dd></dl>
<p>Now the Radar is ready and starts to receive samples from the configured antennas. The following code snippet can be used as an example to get a frame of data. This code can be structured as a loop block for 'num_frames' number of frames as shown below</p>
<dl class="section user"><dt>Code Listing 2.4.2</dt><dd><pre class="fragment"># A loop for fetching a finite number of frames
for frame_number in range(num_frames):
    device.get_next_frame(frame)
    mat = frame.get_mat_from_antenna(0)
</pre></dd></dl>
<p>The device starts to transmit data samples from each configured antenna according to the frame repetition rate. The method 'get_mat_from_antenna(antenna_num)' is used to access samples for a single antenna from the frame handle.</p>
<p>In the above example mat will be an matrix consisting receive samples from antenna 0.</p>
<p>The matrix shape is defined by the number of chirps per frame, and samples per chirp as rows and columns respectively. This information can be derived as follows</p>
<dl class="section user"><dt>Code Listing 2.4.3</dt><dd><pre class="fragment">[numchirps, chirpsamples] = np.shape(mat)
</pre></dd></dl>
<p>The frame data from the Radar is available within the 'for' block in code listing 2.4.2. A data processing routine can be placed here. An example of data processing is given in <a class="el" href="pg_rdk_python.html#sct_rdk_python_running_the_algoexample">2.5 A presence sensing application</a>.</p>
<h2><a class="anchor" id="sct_rdk_python_running_the_algoexample"></a>
2.5 A presence sensing application</h2>
<p>This section illustrates how to write a simple application for presence detection. The code snippets illustrate the main steps, the actual implementation is in the file presence_detection.py in the directory apps/py/examples/.</p>
<h3><a class="anchor" id="sct_rdk_python_presence_config"></a>
2.5.1 Configuring the Radar and algorithm</h3>
<p>The Radar is tuned so the presence sensing returns "true" when it detects an object in the range of 20-80cm from the Radar shield's planar face. The configuration can be derived using these requirements. For details on how to derive the configuration please refer to <a class="el" href="pg_radarsdk_device_config_guide.html#ssct_radarsdk_device_config_guide_params">Radar device configuration parameters</a>. The following configuration is used to configure a single receive antenna and a detection range of 1.6 meters.</p>
<dl class="section user"><dt>Code Listing 2.5.1</dt><dd><pre class="fragment"># set device configuration for presence sensing
device.set_config(
    sample_rate_Hz = 1e6,                   # ADC sample rate of 1MHz
    rx_mask = 1,                            # RX antenna 1 activated
    tx_mask = 1,                            # TX antenna 1 activated
    tx_power_level = 31,                    # TX power level of 31
    if_gain_dB = 33,                        # 33dB if gain
    lower_frequency_Hz = 59_133_931_281,    # lower frequency: 59.133931281 GHz
    upper_frequency_Hz = 62_366_068_720,    # upper frequency: 62.366068720 GHz
    num_samples_per_chirp = 64,             # 64 samples per chirp
    num_chirps_per_frame = 32,              # 32 chirps per frame
    chirp_repetition_time_s = 0.000411238,  # Chirp repetition time (or pulse repetition time) of 411.238us
    frame_repetition_time_s = 0.125,        # Frame repetition time of 0.125s (frame rate of 8Hz)
    mimo_mode = "off")                      # MIMO disabled
</pre></dd></dl>
<p>The algorithm needs certain parameters which are used in subsequent steps and are configured/initialized as</p>
<dl class="section user"><dt>Code Listing 2.5.2</dt><dd><pre class="fragment"># Presence sensing algorithm parameters
detect_start_sample = chirpsamples//8       # detection start sample corresponding to 20cm
detect_end_sample = chirpsamples//2         # detection end sample corresponding to 80cm
threshold_presence = 0.0007                 # threshold for object detection
alpha_slow = 0.001                          # slow average update coefficient
alpha_med = 0.05                            # medium average update coefficient
alpha_fast = 0.6                            # fast average update coefficient
</pre></dd></dl>
<p>This configures a detection range of 20cm to 80cm. The threshold presence is set to a value based on experimentation giving a reasonable detection with an object presence e.g. a hand.</p>
<h3><a class="anchor" id="sct_rdk_python_fft_spectrum"></a>
2.5.2 Computing Radar distance data</h3>
<p>Once the antenna data is available in the variable 'mat', the range FFT is computed using the following steps</p>
<dl class="section user"><dt>Step 1: remove DC bias from samples</dt><dd><pre class="fragment">avgs = np.average(mat,1).reshape(numchirps,1)
mat = mat - avgs
</pre></dd></dl>
<dl class="section user"><dt>Step 2: Window the data before zero padding</dt><dd></dd></dl>
<p>To run this step, the scipy.signal library needs to be imported, which contains the definition and reference to the Blackman-Harris Window. To install scipy, please refer to Code Listing 1.1.2. This import can be added to the list of imports in Code Listing 2.1.1</p>
<dl class="section user"><dt></dt><dd><pre class="fragment">import scipy.signal as signal
</pre> <pre class="fragment">mat = np.multiply(mat,signal.blackmanharris(chirpsamples).reshape(1,chirpsamples))
</pre></dd></dl>
<dl class="section user"><dt>Step 3: Add zero padding for higher resolution FFT</dt><dd><pre class="fragment">zp1 = np.pad(mat,((0,0),(0,chirpsamples)),'constant')
</pre></dd></dl>
<dl class="section user"><dt>Step 4: compute FFT and select the non zero spectrum for Range information</dt><dd><pre class="fragment">range_fft = np.fft.fft(zp1)/chirpsamples
range_fft = 2*range_fft[:,range(int(chirpsamples))]
</pre></dd></dl>
<p>The above steps used to compute distance data have been compiled in a Python function 'fft_spectrum.py' residing in the SDK Python wrapper directory.</p>
<h3><a class="anchor" id="sct_rdk_python_presence_algo"></a>
2.5.3 Presence sensing algorithm</h3>
<p>To detect presence, the absolute values of the range FFT data are averaged over chirps in a frame and filtered with a slow single tap IIR filter and a fast single tap IIR filter.</p>
<dl class="section user"><dt>Step 1: Compute absolute FFT values and chirp average</dt><dd></dd></dl>
<p>In this step, the absolute FFT values are computed and averaged over the chirps in the frame.</p>
<dl class="section user"><dt></dt><dd><pre class="fragment">fft_abs = abs(range_fft)
fft_avg = np.divide(fft_abs.sum(axis=0), numchirps)
</pre></dd></dl>
<dl class="section user"><dt>Step 2: Compute slow and fast average updates</dt><dd></dd></dl>
<p>The slow and fast average vectors are initialized to the first 'fft_avg'. The slow averaging coefficient is chosen depending on the detection status. The idea is to slow down the reference update once an object is detected. </p><dl class="section user"><dt></dt><dd><pre class="fragment">if frame_number == 0: # initialize average updates
    slow_avg = fft_avg
    fast_avg = fft_avg

# Choose slow coefficient
if presence_status == False:
    alpha_used = alpha_med
else:
    alpha_used = alpha_slow

slow_avg = slow_avg*(1-alpha_used) + fft_avg*alpha_used
fast_avg = fast_avg*(1-alpha_fast) + fft_avg*alpha_fast
data = (fast_avg-slow_avg)
</pre></dd></dl>
<p>for detection the difference 'data' between the fast filtered output and the slow filtered output can be used to identify the appearance of a new object in the detection range. The presence state decision is then made based on a threshold. The detection range, speed of slow and fast filtering can be treated as algorithm parameters</p>
<dl class="section user"><dt>Step 3: Detection Logic</dt><dd><pre class="fragment">presence_status = (np.max(data[detect_start_sample:detect_end_sample])&gt;threshold_presence)
</pre></dd></dl>
<h2><a class="anchor" id="sct_rdk_python_algoext"></a>
2.6 Extension into an anti-peeking application</h2>
<p>as mentioned in <a class="el" href="pg_rdk_python.html#sct_rdk_python_running_the_algoexample">2.5 A presence sensing application</a>, the detection range, the speed of slow and fast filtering can be treated as algorithm parameters. For a slightly more complex anti-peeking application showcasing the Radar's multiple object detection capability, a second instance of of the algorithm needs to be run on the same data with a different set of range and threshold parameters. <br  />
</p><dl class="section user"><dt>Use Case</dt><dd></dd></dl>
<p>The intention of this application is a scenario where the radar is mounted on your laptop screen and the intention is to detect the user and an additional alarm when someone peeking from behind is detected. for this purpose it is required to define an additional start and end range.</p>
<div class="image">
<img src="img_python_fig_2_output_of_presence_det.png" alt="" width="600px"/>
<div class="caption">
Figure 2.1 Output of presence_detection.py.</div></div>
<p> <br  />
The same algorithm is run twice resulting in two detections as can be seen from the example app output in Figure 2.1. This application can be found in 'RDK/apps/py/examples/presence_detection.py' which is part of the release package. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Dec 16 2021 15:55:56 for Radar SDK Documentation by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
